<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>souffle: souffle::ast::transform::MaterializeAggregationQueriesTransformer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">souffle
   &#160;<span id="projectnumber">2.0.2-321-gfbb4c4b</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesouffle.html">souffle</a></li><li class="navelem"><a class="el" href="namespacesouffle_1_1ast.html">ast</a></li><li class="navelem"><a class="el" href="namespacesouffle_1_1ast_1_1transform.html">transform</a></li><li class="navelem"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer.html">MaterializeAggregationQueriesTransformer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">souffle::ast::transform::MaterializeAggregationQueriesTransformer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Transformation pass to create artificial relations for bodies of aggregation functions consisting of more than a single atom.  
 <a href="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_materialize_aggregation_queries_8h_source.html">MaterializeAggregationQueries.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for souffle::ast::transform::MaterializeAggregationQueriesTransformer:</div>
<div class="dyncontent">
<div class="center"><img src="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer__inherit__graph.png" border="0" usemap="#souffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer_inherit__map" alt="Inheritance graph"/></div>
<map name="souffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer_inherit__map" id="souffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer_inherit__map">
<area shape="rect" title="Transformation pass to create artificial relations for bodies of aggregation functions consisting of ..." alt="" coords="5,204,256,413"/>
<area shape="rect" href="classsouffle_1_1ast_1_1transform_1_1_transformer.html" title=" " alt="" coords="47,5,214,156"/>
</map>
</div>
<div class="dynheader">
Collaboration diagram for souffle::ast::transform::MaterializeAggregationQueriesTransformer:</div>
<div class="dyncontent">
<div class="center"><img src="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer__coll__graph.png" border="0" usemap="#souffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer_coll__map" alt="Collaboration graph"/></div>
<map name="souffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer_coll__map" id="souffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer_coll__map">
<area shape="rect" title="Transformation pass to create artificial relations for bodies of aggregation functions consisting of ..." alt="" coords="5,204,256,413"/>
<area shape="rect" href="classsouffle_1_1ast_1_1transform_1_1_transformer.html" title=" " alt="" coords="47,5,214,156"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaa083c09eb46f05eecbf109deb8ac974"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer.html">MaterializeAggregationQueriesTransformer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer.html#aaa083c09eb46f05eecbf109deb8ac974">clone</a> () const override</td></tr>
<tr class="separator:aaa083c09eb46f05eecbf109deb8ac974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7300aec0bdf0d998183bbe7dbbf60d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer.html#ace7300aec0bdf0d998183bbe7dbbf60d">getName</a> () const override</td></tr>
<tr class="separator:ace7300aec0bdf0d998183bbe7dbbf60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsouffle_1_1ast_1_1transform_1_1_transformer"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classsouffle_1_1ast_1_1transform_1_1_transformer')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classsouffle_1_1ast_1_1transform_1_1_transformer.html">souffle::ast::transform::Transformer</a></td></tr>
<tr class="memitem:aa2a19006120091a83d662c3cfb56b528 inherit pub_methods_classsouffle_1_1ast_1_1transform_1_1_transformer"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_transformer.html#aa2a19006120091a83d662c3cfb56b528">apply</a> (<a class="el" href="classsouffle_1_1ast_1_1_translation_unit.html">TranslationUnit</a> &amp;translationUnit)</td></tr>
<tr class="separator:aa2a19006120091a83d662c3cfb56b528 inherit pub_methods_classsouffle_1_1ast_1_1transform_1_1_transformer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa625c305cc624b42b2829d67ccf44a44 inherit pub_methods_classsouffle_1_1ast_1_1transform_1_1_transformer"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_transformer.html#aa625c305cc624b42b2829d67ccf44a44">~Transformer</a> ()=default</td></tr>
<tr class="separator:aa625c305cc624b42b2829d67ccf44a44 inherit pub_methods_classsouffle_1_1ast_1_1transform_1_1_transformer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae2fb95a2da3c8f1dd34aff9d9299704d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer.html#ae2fb95a2da3c8f1dd34aff9d9299704d">materializeAggregationQueries</a> (<a class="el" href="classsouffle_1_1ast_1_1_translation_unit.html">TranslationUnit</a> &amp;translationUnit)</td></tr>
<tr class="memdesc:ae2fb95a2da3c8f1dd34aff9d9299704d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates artificial relations for bodies of aggregation functions consisting of more than a single atom, in the given program.  <a href="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer.html#ae2fb95a2da3c8f1dd34aff9d9299704d">More...</a><br /></td></tr>
<tr class="separator:ae2fb95a2da3c8f1dd34aff9d9299704d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:abe3faf3909927c50112cc23824e2153e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer.html#abe3faf3909927c50112cc23824e2153e">transform</a> (<a class="el" href="classsouffle_1_1ast_1_1_translation_unit.html">TranslationUnit</a> &amp;translationUnit) override</td></tr>
<tr class="separator:abe3faf3909927c50112cc23824e2153e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a7f8a7cdbad4c5a5a5398055eec217693"><td class="memItemLeft" align="right" valign="top">static std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer.html#a7f8a7cdbad4c5a5a5398055eec217693">distinguishHeadArguments</a> (const <a class="el" href="classsouffle_1_1ast_1_1_translation_unit.html">TranslationUnit</a> &amp;tu, const <a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> &amp;clause, const <a class="el" href="classsouffle_1_1ast_1_1_aggregator.html">Aggregator</a> &amp;aggregate)</td></tr>
<tr class="memdesc:a7f8a7cdbad4c5a5a5398055eec217693"><td class="mdescLeft">&#160;</td><td class="mdescRight">When we materialise an aggregate subclause, it's a good question which variables belong in the head of that materialised clause and which don't.  <a href="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer.html#a7f8a7cdbad4c5a5a5398055eec217693">More...</a><br /></td></tr>
<tr class="separator:a7f8a7cdbad4c5a5a5398055eec217693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f0ae183cb14d8dab6bff286cb8ef95"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer.html#ad6f0ae183cb14d8dab6bff286cb8ef95">groundInjectedParameters</a> (const <a class="el" href="classsouffle_1_1ast_1_1_translation_unit.html">TranslationUnit</a> &amp;translationUnit, <a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> &amp;aggClause, const <a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> &amp;originalClause, const <a class="el" href="classsouffle_1_1ast_1_1_aggregator.html">Aggregator</a> &amp;aggregate)</td></tr>
<tr class="memdesc:ad6f0ae183cb14d8dab6bff286cb8ef95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the aggClause by adding in grounding literals for every variable that appears in the clause ungrounded.  <a href="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer.html#ad6f0ae183cb14d8dab6bff286cb8ef95">More...</a><br /></td></tr>
<tr class="separator:ad6f0ae183cb14d8dab6bff286cb8ef95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4b4d7ce2c25b557e68ee063f91d31e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer.html#a7e4b4d7ce2c25b557e68ee063f91d31e">instantiateUnnamedVariables</a> (<a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> &amp;aggClause)</td></tr>
<tr class="memdesc:a7e4b4d7ce2c25b557e68ee063f91d31e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whatever variables have been left unnamed have significance for a count aggregate.  <a href="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer.html#a7e4b4d7ce2c25b557e68ee063f91d31e">More...</a><br /></td></tr>
<tr class="separator:a7e4b4d7ce2c25b557e68ee063f91d31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd0bb77f62c0558f5c4213bce49bf12"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer.html#aacd0bb77f62c0558f5c4213bce49bf12">needsMaterializedRelation</a> (const <a class="el" href="classsouffle_1_1ast_1_1_aggregator.html">Aggregator</a> &amp;agg)</td></tr>
<tr class="memdesc:aacd0bb77f62c0558f5c4213bce49bf12"><td class="mdescLeft">&#160;</td><td class="mdescRight">A test determining whether the body of a given aggregation needs to be 'outlined' into an independent relation or can be kept inline.  <a href="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer.html#aacd0bb77f62c0558f5c4213bce49bf12">More...</a><br /></td></tr>
<tr class="separator:aacd0bb77f62c0558f5c4213bce49bf12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Transformation pass to create artificial relations for bodies of aggregation functions consisting of more than a single atom. </p>

<p class="definition">Definition at line <a class="el" href="_materialize_aggregation_queries_8h_source.html#l00037">37</a> of file <a class="el" href="_materialize_aggregation_queries_8h_source.html">MaterializeAggregationQueries.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aaa083c09eb46f05eecbf109deb8ac974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa083c09eb46f05eecbf109deb8ac974">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer.html">MaterializeAggregationQueriesTransformer</a>* souffle::ast::transform::MaterializeAggregationQueriesTransformer::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classsouffle_1_1ast_1_1transform_1_1_transformer.html#a0fa9b23c1d9568a3115147a85f89ed68">souffle::ast::transform::Transformer</a>.</p>

<p class="definition">Definition at line <a class="el" href="_materialize_aggregation_queries_8h_source.html#l00059">59</a> of file <a class="el" href="_materialize_aggregation_queries_8h_source.html">MaterializeAggregationQueries.h</a>.</p>

</div>
</div>
<a id="a7f8a7cdbad4c5a5a5398055eec217693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f8a7cdbad4c5a5a5398055eec217693">&#9670;&nbsp;</a></span>distinguishHeadArguments()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; std::string &gt; souffle::ast::transform::MaterializeAggregationQueriesTransformer::distinguishHeadArguments </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1_translation_unit.html">TranslationUnit</a> &amp;&#160;</td>
          <td class="paramname"><em>tu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> &amp;&#160;</td>
          <td class="paramname"><em>clause</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1_aggregator.html">Aggregator</a> &amp;&#160;</td>
          <td class="paramname"><em>aggregate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When we materialise an aggregate subclause, it's a good question which variables belong in the head of that materialised clause and which don't. </p>
<p>For a count aggregate for example, it's important that all variables (even unnamed ones) appearing in the subclause are given a space in the head. For min and max aggregates, we know that the entire subclause (as is the case for any aggregate) will need to appear as the body of the materialised rule, but what goes in the head is a bit less straightforward. We could get away with only exporting the column that we are taking the maximum over, because this is the only value that we need to retrieve. The same can be said for sum and mean.</p>
<p>BUT there is a caveat: We support the construct of witnesses to an aggregate calculation. A witness is some variable present in the aggregate subclause that is exported <em>ungrounded</em> to the base scope. If we do save all configurations of the variables in the aggregate subclause (as we are doing when we materialise it), then we can reuse this materialised subclause to retrieve the witness almost instantly.</p>
<p>(This is assuming that we have a good enough machinery to recognise when rules are exactly the same, because the witness transformation actually has to take place BEFORE the materialisation, meaning that there will be two separate relations that actually will represent exactly the same relation semantically, and we would want those to be recognised as a single relation)</p>
<p>So not only then (assuming we have good "equality of rules" machinery) does using the "count" aggregate technique (just giving each variable a place in the head) allow us to save and retrieve witnesses easily, but it also just makes the treatment of aggregates uniform, which I suppose is simpler, nicer, more aesthetic maybe.</p>
<p>Giving min/max/mean/sum aggregate materialised relations only a single column would be far more efficient, but then we would lose the ability to retrieve witnesses. So this was the tradeoff, and losing witnesses is just not an option. We NEED them to be able to give the user witness functionality.</p>
<p>To clarify, we don't want to include local variables of any inner aggregates appearing in this aggregate. My reasoning for deciding this was really just a hunch that I felt like local variables of an inner aggregate should be totally irrelevant. So we include "immediate" local variables, not local variables of any inner aggregate.</p>
<p>The other thing we must include is any injected variables. Depending on the assignment of the injected variable, the aggregate's value may change, but so, still, why would it be important to include the injected variable in the head then? </p><pre class="fragment">  A(x, n) :- B(x), n = sum y : { C(y, x) }.
</pre><p>Because we need the assignment of x in the outer scope to COINCIDE with the assignment of x in the inner scope. The only thing visible to the outer scope is whatever is in the head. That is good enough justification. And this applies to any type of aggregate.</p>
<p>So the overall conclusion is that what we should include are:</p><ul>
<li>injected variables</li>
<li><em>immediate</em> local variables </li>
</ul>
<p>The head atom should contain immediate local and injected variables. No witnesses! They have already been transformed away. This means that we exclude any inner aggregate local variables. But we do NOT exclude inner aggregate injected variables!! It's important that the injected variable ends up in this head so that we do not obfuscate the injected variable's relationship to the outer scope. It does not affect the aggregate value because adding an extra column for the injected variable, where that column will only have one value at a time, will essentially replicate the aggregate body relation for as many possible values of the injected variable that there are. The fact that the injected variable will take one value at a time is key.</p>

<p class="definition">Definition at line <a class="el" href="_materialize_aggregation_queries_8cpp_source.html#l00077">77</a> of file <a class="el" href="_materialize_aggregation_queries_8cpp_source.html">MaterializeAggregationQueries.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;                                  : <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#ac1acc981f913d4ad9865fb655fe5e1f2">analysis::getLocalVariables</a>(tu, clause, aggregate)) {</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;        headArguments.insert(localVarName);</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    }</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    <span class="comment">// find local variables of inner aggregate and remove them</span></div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    <a class="code" href="namespacesouffle_1_1ast.html#a0bf6b9bdf0a8866bd27dde18442ab43d">visitDepthFirst</a>(aggregate, [&amp;](<span class="keyword">const</span> Aggregator&amp; innerAggregate) {</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;        <span class="keywordflow">if</span> (aggregate == innerAggregate) {</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;            <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;        }</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; innerLocalVariableName : <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#ac1acc981f913d4ad9865fb655fe5e1f2">analysis::getLocalVariables</a>(tu, clause, innerAggregate)) {</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;            headArguments.erase(innerLocalVariableName);</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;        }</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    });</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    <span class="comment">// find injected variables of this aggregate and add them</span></div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; injectedVarName : <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#abbc7e3bf641dffe8a8dd0db3a8b44712">analysis::getInjectedVariables</a>(tu, clause, aggregate)) {</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;        headArguments.insert(injectedVarName);</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    }</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    <span class="keywordflow">return</span> headArguments;</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;}</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160; </div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;<span class="comment">// TODO (Issue 1696): Deal with recursive parameters with an assert statement.</span></div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;<span class="keywordtype">void</span> <a class="code" href="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer.html#ad6f0ae183cb14d8dab6bff286cb8ef95">MaterializeAggregationQueriesTransformer::groundInjectedParameters</a>(</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;        <span class="keyword">const</span> TranslationUnit&amp; translationUnit, Clause&amp; aggClause, <span class="keyword">const</span> Clause&amp; originalClause,</div>
</div><!-- fragment -->
</div>
</div>
<a id="ace7300aec0bdf0d998183bbe7dbbf60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace7300aec0bdf0d998183bbe7dbbf60d">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::ast::transform::MaterializeAggregationQueriesTransformer::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classsouffle_1_1ast_1_1transform_1_1_transformer.html#a69dfaf1387c8b03440b352ff7eebae4e">souffle::ast::transform::Transformer</a>.</p>

<p class="definition">Definition at line <a class="el" href="_materialize_aggregation_queries_8h_source.html#l00046">46</a> of file <a class="el" href="_materialize_aggregation_queries_8h_source.html">MaterializeAggregationQueries.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;       :</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    <span class="keywordtype">bool</span> <a class="code" href="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer.html#abe3faf3909927c50112cc23824e2153e">transform</a>(TranslationUnit&amp; translationUnit)<span class="keyword"> override </span>{</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad6f0ae183cb14d8dab6bff286cb8ef95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f0ae183cb14d8dab6bff286cb8ef95">&#9670;&nbsp;</a></span>groundInjectedParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void souffle::ast::transform::MaterializeAggregationQueriesTransformer::groundInjectedParameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1_translation_unit.html">TranslationUnit</a> &amp;&#160;</td>
          <td class="paramname"><em>translationUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> &amp;&#160;</td>
          <td class="paramname"><em>aggClause</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> &amp;&#160;</td>
          <td class="paramname"><em>originalClause</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1_aggregator.html">Aggregator</a> &amp;&#160;</td>
          <td class="paramname"><em>aggregate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the aggClause by adding in grounding literals for every variable that appears in the clause ungrounded. </p>
<p>The source of literals to copy from is the originalClause. </p>
<p>Mask inner aggregates to make sure we don't consider them grounded and everything.</p>
<p>Go through body literals. If the literal is an atom, then replace the atom with a negated version of the atom, so that injected parameters that occur in an inner aggregate don't "seem" grounded.</p>

<p class="definition">Definition at line <a class="el" href="_materialize_aggregation_queries_8cpp_source.html#l00114">114</a> of file <a class="el" href="_materialize_aggregation_queries_8cpp_source.html">MaterializeAggregationQueries.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;                                : <span class="keyword">public</span> NodeMapper {</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;        std::unique_ptr&lt;Node&gt; operator()(std::unique_ptr&lt;Node&gt; node)<span class="keyword"> const override </span>{</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;            <span class="keywordflow">if</span> (<span class="keyword">auto</span>* aggregate = <span class="keyword">dynamic_cast&lt;</span>Aggregator*<span class="keyword">&gt;</span>(node.get())) {<span class="comment"></span></div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;<span class="comment">                /**</span></div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;<span class="comment">                 * Go through body literals. If the literal is an atom,</span></div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;<span class="comment">                 * then replace the atom with a negated version of the atom, so that</span></div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;<span class="comment">                 * injected parameters that occur in an inner aggregate don&#39;t &quot;seem&quot; grounded.</span></div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;<span class="comment">                 **/</span></div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;                std::vector&lt;Own&lt;Literal&gt;&gt; newBody;</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; lit : aggregate-&gt;getBodyLiterals()) {</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;                    <span class="keywordflow">if</span> (<span class="keyword">auto</span>* atom = <span class="keyword">dynamic_cast&lt;</span>Atom*<span class="keyword">&gt;</span>(lit)) {</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;                        newBody.push_back(mk&lt;Negation&gt;(<a class="code" href="namespacesouffle.html#adea839071e91666e99dedc870a42941c">souffle::clone</a>(atom)));</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;                    }</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;                }</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;                aggregate-&gt;setBody(std::move(newBody));</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;            }</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;            node-&gt;apply(*<span class="keyword">this</span>);</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;            <span class="keywordflow">return</span> node;</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;        }</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;    };</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160; </div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    <span class="keyword">auto</span> aggClauseInnerAggregatesMasked = <a class="code" href="namespacesouffle.html#adea839071e91666e99dedc870a42941c">souffle::clone</a>(&amp;aggClause);</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;    aggClauseInnerAggregatesMasked-&gt;setHead(mk&lt;Atom&gt;(<span class="stringliteral">&quot;*&quot;</span>));</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;    NegateAggregateAtoms update;</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;    aggClauseInnerAggregatesMasked-&gt;apply(update);</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160; </div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;    <span class="comment">// what is the set of injected variables? Those are the ones we need to ground.</span></div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;    std::set&lt;std::string&gt; injectedVariables =</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;            <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#abbc7e3bf641dffe8a8dd0db3a8b44712">analysis::getInjectedVariables</a>(translationUnit, originalClause, aggregate);</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160; </div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;    std::set&lt;std::string&gt; alreadyGrounded;</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; argPair : <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#a108a2d9570b44c655bf3165e8d8613d4">analysis::getGroundedTerms</a>(translationUnit, *aggClauseInnerAggregatesMasked)) {</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;        <span class="keyword">const</span> <span class="keyword">auto</span>* variable = <span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span>ast::Variable*<span class="keyword">&gt;</span>(argPair.first);</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;        <span class="keywordtype">bool</span> variableIsGrounded = argPair.second;</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;        <span class="keywordflow">if</span> (variable == <span class="keyword">nullptr</span> || variableIsGrounded) {</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;            <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;        }</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;        <span class="comment">// If it&#39;s not an injected variable, we don&#39;t need to ground it</span></div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;        <span class="keywordflow">if</span> (injectedVariables.find(variable-&gt;getName()) == injectedVariables.end()) {</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;            <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;        }</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160; </div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;        std::string ungroundedVariableName = variable-&gt;getName();</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;        <span class="keywordflow">if</span> (alreadyGrounded.find(ungroundedVariableName) != alreadyGrounded.end()) {</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;            <span class="comment">// may as well not bother with it because it has already</span></div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;            <span class="comment">// been grounded in a previous iteration</span></div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;            <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;        }</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;        <span class="comment">// Try to find any atom in the rule where this ungrounded variable is mentioned</span></div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; lit : originalClause.getBodyLiterals()) {</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;            <span class="comment">// -1. This may not be the same literal</span></div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;            <span class="keywordtype">bool</span> originalAggregateFound = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;            <a class="code" href="namespacesouffle_1_1ast.html#a0bf6b9bdf0a8866bd27dde18442ab43d">visitDepthFirst</a>(*lit, [&amp;](<span class="keyword">const</span> Aggregator&amp; a) {</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;                <span class="keywordflow">if</span> (a == aggregate) {</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;                    originalAggregateFound = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;                    <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;                }</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;            });</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;            <span class="keywordflow">if</span> (originalAggregateFound) {</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;                <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;            }</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;            <span class="comment">// 0. Variable must not already have been grounded</span></div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;            <span class="keywordflow">if</span> (alreadyGrounded.find(ungroundedVariableName) != alreadyGrounded.end()) {</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;                <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;            }</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;            <span class="comment">// 1. Variable must occur in this literal</span></div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;            <span class="keywordtype">bool</span> variableOccursInLit = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;            <a class="code" href="namespacesouffle_1_1ast.html#a0bf6b9bdf0a8866bd27dde18442ab43d">visitDepthFirst</a>(*lit, [&amp;](<span class="keyword">const</span> Variable&amp; var) {</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;                <span class="keywordflow">if</span> (var.getName() == ungroundedVariableName) {</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;                    variableOccursInLit = true;</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;                }</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;            });</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;            <span class="keywordflow">if</span> (!variableOccursInLit) {</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;                <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;            }</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;            <span class="comment">// 2. Variable must be grounded by this literal.</span></div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;            <span class="keyword">auto</span> singleLiteralClause = mk&lt;Clause&gt;();</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;            singleLiteralClause-&gt;addToBody(<a class="code" href="namespacesouffle.html#adea839071e91666e99dedc870a42941c">souffle::clone</a>(lit));</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;            <span class="keywordtype">bool</span> variableGroundedByLiteral = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; argPair : <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#a108a2d9570b44c655bf3165e8d8613d4">analysis::getGroundedTerms</a>(translationUnit, *singleLiteralClause)) {</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;                <span class="keyword">const</span> <span class="keyword">auto</span>* var = <span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span>ast::Variable*<span class="keyword">&gt;</span>(argPair.first);</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;                <span class="keywordflow">if</span> (var == <span class="keyword">nullptr</span>) {</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;                    <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;                }</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;                <span class="keywordtype">bool</span> isGrounded = argPair.second;</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;                <span class="keywordflow">if</span> (var-&gt;getName() == ungroundedVariableName &amp;&amp; isGrounded) {</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;                    variableGroundedByLiteral = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;                }</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;            }</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;            <span class="keywordflow">if</span> (!variableGroundedByLiteral) {</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;                <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;            }</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;            <span class="comment">// 3. if it&#39;s an atom:</span></div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;            <span class="comment">//  the relation must be of a lower stratum for us to be able to add it. (not implemented)</span></div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;            <span class="comment">//  sanitise the atom by removing any unnecessary arguments that aren&#39;t constants</span></div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;            <span class="comment">//  or basically just any other variables</span></div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;            <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* atom = <span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span>Atom*<span class="keyword">&gt;</span>(lit)) {</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;                <span class="comment">// Right now we only allow things to be grounded by atoms.</span></div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;                <span class="comment">// This is limiting but the case of it being grounded by</span></div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;                <span class="comment">// something else becomes complicated VERY quickly.</span></div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;                <span class="comment">// It may involve pulling in a cascading series of literals like</span></div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;                <span class="comment">// x = y, y = 4. It just seems very painful.</span></div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;                <span class="comment">// remove other unnecessary bloating arguments and replace with an underscore</span></div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;                VecOwn&lt;Argument&gt; arguments;</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">auto</span> arg : atom-&gt;getArguments()) {</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;                    <span class="keywordflow">if</span> (<span class="keyword">auto</span>* var = <span class="keyword">dynamic_cast&lt;</span>ast::Variable*<span class="keyword">&gt;</span>(arg)) {</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;                        <span class="keywordflow">if</span> (var-&gt;getName() == ungroundedVariableName) {</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;                            arguments.emplace_back(arg-&gt;clone());</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;                            <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;                        }</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;                    }</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;                    arguments.emplace_back(<span class="keyword">new</span> UnnamedVariable());</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;                }</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160; </div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;                <span class="keyword">auto</span> groundingAtom =</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;                        mk&lt;Atom&gt;(atom-&gt;getQualifiedName(), std::move(arguments), atom-&gt;getSrcLoc());</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;                aggClause.addToBody(<a class="code" href="namespacesouffle.html#adea839071e91666e99dedc870a42941c">souffle::clone</a>(groundingAtom));</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;                alreadyGrounded.insert(ungroundedVariableName);</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;            }</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;        }</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;        assert(alreadyGrounded.find(ungroundedVariableName) != alreadyGrounded.end() &amp;&amp;</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;                <span class="stringliteral">&quot;Error: Unable to ground parameter in materialisation-requiring aggregate body&quot;</span>);</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;        <span class="comment">// after this loop, we should have added at least one thing to provide a grounding.</span></div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;        <span class="comment">// If not, we should error out. The program will not be able to run.</span></div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;        <span class="comment">// We have an ungrounded variable that we cannot ground once the aggregate body is</span></div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;        <span class="comment">// outlined.</span></div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;    }</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;}</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160; </div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;<span class="keywordtype">bool</span> <a class="code" href="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer.html#ae2fb95a2da3c8f1dd34aff9d9299704d">MaterializeAggregationQueriesTransformer::materializeAggregationQueries</a>(</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;        TranslationUnit&amp; translationUnit) {</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;    <span class="keywordtype">bool</span> changed = <span class="keyword">false</span>;</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="_container_util_8h_source.html#l00172">souffle::clone()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer_ad6f0ae183cb14d8dab6bff286cb8ef95_cgraph.png" border="0" usemap="#classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer_ad6f0ae183cb14d8dab6bff286cb8ef95_cgraph" alt=""/></div>
<map name="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer_ad6f0ae183cb14d8dab6bff286cb8ef95_cgraph" id="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer_ad6f0ae183cb14d8dab6bff286cb8ef95_cgraph">
<area shape="rect" title="Modify the aggClause by adding in grounding literals for every variable that appears in the clause un..." alt="" coords="5,5,284,61"/>
<area shape="rect" href="namespacesouffle.html#adea839071e91666e99dedc870a42941c" title=" " alt="" coords="332,20,441,47"/>
</map>
</div>

</div>
</div>
<a id="a7e4b4d7ce2c25b557e68ee063f91d31e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e4b4d7ce2c25b557e68ee063f91d31e">&#9670;&nbsp;</a></span>instantiateUnnamedVariables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void souffle::ast::transform::MaterializeAggregationQueriesTransformer::instantiateUnnamedVariables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_clause.html">Clause</a> &amp;&#160;</td>
          <td class="paramname"><em>aggClause</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whatever variables have been left unnamed have significance for a count aggregate. </p>
<p>They NEED to be in the head of the materialized atom that will replace this aggregate subclause. Therefore, we give them dummy names (_n rather than just _) so that the count will be correct. </p>

<p class="definition">Definition at line <a class="el" href="_materialize_aggregation_queries_8cpp_source.html#l00053">53</a> of file <a class="el" href="_materialize_aggregation_queries_8cpp_source.html">MaterializeAggregationQueries.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;                                                            {</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;            <span class="keywordflow">if</span> (isA&lt;UnnamedVariable&gt;(node.get())) {</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;                <span class="keywordflow">return</span> mk&lt;Variable&gt;(<span class="stringliteral">&quot;_&quot;</span> + <a class="code" href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">toString</a>(<a class="code" href="namespacesouffle_1_1test.html#a10453085bc4f71f32dcda443d4b3c446">count</a>++));</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;            }</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;            <span class="keywordflow">if</span> (isA&lt;Aggregator&gt;(node.get())) {</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;                <span class="comment">// then DON&#39;T recurse</span></div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;                <span class="keywordflow">return</span> node;</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;            }</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;            node-&gt;apply(*<span class="keyword">this</span>);</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;            <span class="keywordflow">return</span> node;</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;        }</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    };</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160; </div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    InstantiateUnnamedVariables update;</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; lit : aggClause.getBodyLiterals()) {</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;        lit-&gt;apply(update);</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    }</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;}</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160; </div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;std::set&lt;std::string&gt; <a class="code" href="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer.html#a7f8a7cdbad4c5a5a5398055eec217693">MaterializeAggregationQueriesTransformer::distinguishHeadArguments</a>(</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;        <span class="keyword">const</span> TranslationUnit&amp; tu, <span class="keyword">const</span> Clause&amp; clause, <span class="keyword">const</span> Aggregator&amp; aggregate) {<span class="comment"></span></div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;<span class="comment">    /**</span></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="table__test_8cpp_source.html#l00040">souffle::test::count()</a>, and <a class="el" href="_string_util_8h_source.html#l00234">souffle::toString()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer_a7e4b4d7ce2c25b557e68ee063f91d31e_cgraph.png" border="0" usemap="#classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer_a7e4b4d7ce2c25b557e68ee063f91d31e_cgraph" alt=""/></div>
<map name="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer_a7e4b4d7ce2c25b557e68ee063f91d31e_cgraph" id="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer_a7e4b4d7ce2c25b557e68ee063f91d31e_cgraph">
<area shape="rect" title="Whatever variables have been left unnamed have significance for a count aggregate." alt="" coords="5,16,307,72"/>
<area shape="rect" href="namespacesouffle_1_1test.html#a10453085bc4f71f32dcda443d4b3c446" title=" " alt="" coords="355,5,497,32"/>
<area shape="rect" href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949" title="A generic function converting strings into strings (trivial case)." alt="" coords="363,56,489,83"/>
</map>
</div>

</div>
</div>
<a id="ae2fb95a2da3c8f1dd34aff9d9299704d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2fb95a2da3c8f1dd34aff9d9299704d">&#9670;&nbsp;</a></span>materializeAggregationQueries()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::ast::transform::MaterializeAggregationQueriesTransformer::materializeAggregationQueries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_translation_unit.html">TranslationUnit</a> &amp;&#160;</td>
          <td class="paramname"><em>translationUnit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates artificial relations for bodies of aggregation functions consisting of more than a single atom, in the given program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">program</td><td>the program to be processed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the program was modified </dd></dl>
<p>GENERAL PROCEDURE FOR MATERIALISING THE BODY OF AN AGGREGATE: NB:</p><ul>
<li>Only bodies with more than one atom or an inner aggregate need to be materialised.</li>
<li>Ignore inner aggregates (they will be unwound in subsequent applications of this transformer)</li>
<li>Copy aggregate body literals into a new clause</li>
<li>Pull in grounding atoms</li>
<li>Set up the head: This will include any local and injected variables in the body.</li>
<li>Instantiate unnamed variables in count operation (idk why but it's fine)</li>
</ul>

<p class="definition">Definition at line <a class="el" href="_materialize_aggregation_queries_8cpp_source.html#l00249">249</a> of file <a class="el" href="_materialize_aggregation_queries_8cpp_source.html">MaterializeAggregationQueries.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;                                                        {</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;        <a class="code" href="namespacesouffle_1_1ast.html#a0bf6b9bdf0a8866bd27dde18442ab43d">visitDepthFirst</a>(agg, [&amp;](<span class="keyword">const</span> Aggregator&amp; innerAgg) {</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;            <span class="keywordflow">if</span> (agg != innerAgg) {</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;                innerAggregates.insert(&amp;innerAgg);</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;            }</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;        });</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;    });</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160; </div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;    <a class="code" href="namespacesouffle_1_1ast.html#a0bf6b9bdf0a8866bd27dde18442ab43d">visitDepthFirst</a>(program, [&amp;](<span class="keyword">const</span> Clause&amp; clause) {</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;        <a class="code" href="namespacesouffle_1_1ast.html#a0bf6b9bdf0a8866bd27dde18442ab43d">visitDepthFirst</a>(clause, [&amp;](<span class="keyword">const</span> Aggregator&amp; agg) {</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;            <span class="keywordflow">if</span> (!<a class="code" href="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer.html#aacd0bb77f62c0558f5c4213bce49bf12">needsMaterializedRelation</a>(agg)) {</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;                <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;            }</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;            <span class="comment">// only materialise bottom level aggregates</span></div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;            <span class="keywordflow">if</span> (innerAggregates.find(&amp;agg) != innerAggregates.end()) {</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;                return;</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;            }</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;            <span class="comment">// begin materialisation process</span></div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;            <span class="keyword">auto</span> aggregateBodyRelationName = <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#aa937ef5b2452a42f1f884003aae88bf0">analysis::findUniqueRelationName</a>(program, <span class="stringliteral">&quot;__agg_subclause&quot;</span>);</div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;            <span class="keyword">auto</span> aggClause = mk&lt;Clause&gt;();</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;            <span class="comment">// quickly copy in all the literals from the aggregate body</span></div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;            for (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; lit : agg.getBodyLiterals()) {</div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;                aggClause-&gt;addToBody(souffle::clone(lit));</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;            }</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;            if (agg.getOperator() == <a class="code" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a4905ac9d6a22bdfc1ae096094ce6248d">AggregateOp::COUNT</a>) {</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;                instantiateUnnamedVariables(*aggClause);</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;            }</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;            <span class="comment">// pull in any necessary grounding atoms</span></div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;            <a class="code" href="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer.html#ad6f0ae183cb14d8dab6bff286cb8ef95">groundInjectedParameters</a>(translationUnit, *aggClause, clause, agg);</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;            <span class="comment">// the head must contain all injected/local variables, but not variables</span></div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;            <span class="comment">// local to any inner aggregates. So we&#39;ll just take a set minus here.</span></div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;            <span class="comment">// auto aggClauseHead = mk&lt;Atom&gt;(aggregateBodyRelationName);</span></div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;            <span class="keyword">auto</span>* aggClauseHead = <span class="keyword">new</span> Atom(aggregateBodyRelationName);</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;            std::set&lt;std::string&gt; headArguments = <a class="code" href="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer.html#a7f8a7cdbad4c5a5a5398055eec217693">distinguishHeadArguments</a>(translationUnit, clause, agg);</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;            <span class="comment">// insert the head arguments into the head atom</span></div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; variableName : headArguments) {</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;                aggClauseHead-&gt;addArgument(mk&lt;Variable&gt;(variableName));</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;            }</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;            aggClause-&gt;setHead(Own&lt;Atom&gt;(aggClauseHead));</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;            <span class="comment">// add them to the relation as well (need to do a bit of type analysis to make this work)</span></div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;            <span class="keyword">auto</span> aggRel = mk&lt;Relation&gt;(aggregateBodyRelationName);</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;            std::map&lt;const Argument*, analysis::TypeSet&gt; argTypes =</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;                    <a class="code" href="classsouffle_1_1ast_1_1analysis_1_1_type_analysis.html#a345c8fe0c38bfd5fe28922eb15fded8f">analysis::TypeAnalysis::analyseTypes</a>(translationUnit, *aggClause);</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160; </div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; cur : aggClauseHead-&gt;getArguments()) {</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;                <span class="comment">// cur will point us to a particular argument</span></div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;                <span class="comment">// that is found in the aggClause</span></div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;                aggRel-&gt;addAttribute(mk&lt;Attribute&gt;(<a class="code" href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">toString</a>(*cur),</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;                        (<a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#a03c482b5c5fefb75d263667dbe6b1995">analysis::isOfKind</a>(argTypes[cur], <a class="code" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a71fed0c3428bf1a2e19af257c4bac379">TypeAttribute::Signed</a>)) ? <span class="stringliteral">&quot;number&quot;</span> : <span class="stringliteral">&quot;symbol&quot;</span>));</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;            }</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;            <span class="comment">// Set up the aggregate body atom that will represent the materialised relation we just created</span></div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;            <span class="comment">// and slip in place of the unrestricted literal(s) body.</span></div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;            <span class="comment">// Now it&#39;s time to update the aggregate body atom. We can now</span></div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;            <span class="comment">// replace the complex body (with literals) with a body with just the single atom referring</span></div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;            <span class="comment">// to the new relation we just created.</span></div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;            <span class="comment">// all local variables will be replaced by an underscore</span></div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;            <span class="comment">// so we should just quickly fetch the set of local variables for this aggregate.</span></div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;            <span class="keyword">auto</span> localVariables = <a class="code" href="namespacesouffle_1_1ast_1_1analysis.html#ac1acc981f913d4ad9865fb655fe5e1f2">analysis::getLocalVariables</a>(translationUnit, clause, agg);</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;            <span class="keywordflow">if</span> (agg.getTargetExpression() != <span class="keyword">nullptr</span>) {</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;                <span class="keyword">const</span> <span class="keyword">auto</span>* targetExpressionVariable =</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;                        <span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span>Variable*<span class="keyword">&gt;</span>(agg.getTargetExpression());</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;                localVariables.erase(targetExpressionVariable-&gt;getName());</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;            }</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;            VecOwn&lt;Argument&gt; args;</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> arg : aggClauseHead-&gt;getArguments()) {</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;                <span class="keywordflow">if</span> (<span class="keyword">auto</span>* var = <span class="keyword">dynamic_cast&lt;</span>ast::Variable*<span class="keyword">&gt;</span>(arg)) {</div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;                    <span class="comment">// replace local variable by underscore if local, only injected or</span></div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;                    <span class="comment">// target variables will appear</span></div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;                    <span class="keywordflow">if</span> (localVariables.find(var-&gt;getName()) != localVariables.end()) {</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;                        args.emplace_back(<span class="keyword">new</span> UnnamedVariable());</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;                        <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;                    }</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;                }</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;                args.emplace_back(arg-&gt;clone());</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;            }</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;            <span class="keyword">auto</span> aggAtom =</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;                    mk&lt;Atom&gt;(aggClauseHead-&gt;getQualifiedName(), std::move(args), aggClauseHead-&gt;getSrcLoc());</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160; </div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;            VecOwn&lt;Literal&gt; newBody;</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;            newBody.push_back(std::move(aggAtom));</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;            <span class="keyword">const_cast&lt;</span>Aggregator&amp;<span class="keyword">&gt;</span>(agg).setBody(std::move(newBody));</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;            <span class="comment">// Now we can just add these new things (relation and its single clause) to the program</span></div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;            program.addClause(std::move(aggClause));</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;            program.addRelation(std::move(aggRel));</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;            changed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;        });</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;    });</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;    <span class="keywordflow">return</span> changed;</div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;}</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160; </div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;<span class="keywordtype">bool</span> <a class="code" href="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer.html#aacd0bb77f62c0558f5c4213bce49bf12">MaterializeAggregationQueriesTransformer::needsMaterializedRelation</a>(<span class="keyword">const</span> Aggregator&amp; agg) {</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;    <span class="comment">// everything with more than 1 atom  =&gt; materialize</span></div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;    <span class="keywordtype">int</span> countAtoms = 0;</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="ast_2utility_2_visitor_8h_source.html#l00273">souffle::ast::visitDepthFirst()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer_ae2fb95a2da3c8f1dd34aff9d9299704d_cgraph.png" border="0" usemap="#classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer_ae2fb95a2da3c8f1dd34aff9d9299704d_cgraph" alt=""/></div>
<map name="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer_ae2fb95a2da3c8f1dd34aff9d9299704d_cgraph" id="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer_ae2fb95a2da3c8f1dd34aff9d9299704d_cgraph">
<area shape="rect" title="Creates artificial relations for bodies of aggregation functions consisting of more than a single ato..." alt="" coords="5,24,267,95"/>
<area shape="rect" href="namespacesouffle_1_1ast.html#a0bf6b9bdf0a8866bd27dde18442ab43d" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="315,39,484,80"/>
<area shape="rect" href="structsouffle_1_1ast_1_1detail_1_1_lambda_visitor.html#a25be59532c20369733ec6bf2e28d8278" title=" " alt="" coords="532,5,759,47"/>
<area shape="rect" href="structsouffle_1_1ast_1_1detail_1_1_lambda_visitor.html#ac4e7f87964de0bd68f27e2167bd33d6c" title=" " alt="" coords="565,71,725,112"/>
</map>
</div>

</div>
</div>
<a id="aacd0bb77f62c0558f5c4213bce49bf12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd0bb77f62c0558f5c4213bce49bf12">&#9670;&nbsp;</a></span>needsMaterializedRelation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::ast::transform::MaterializeAggregationQueriesTransformer::needsMaterializedRelation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1ast_1_1_aggregator.html">Aggregator</a> &amp;&#160;</td>
          <td class="paramname"><em>agg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A test determining whether the body of a given aggregation needs to be 'outlined' into an independent relation or can be kept inline. </p>

<p class="definition">Definition at line <a class="el" href="_materialize_aggregation_queries_8cpp_source.html#l00357">357</a> of file <a class="el" href="_materialize_aggregation_queries_8cpp_source.html">MaterializeAggregationQueries.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;                             : agg.getBodyLiterals()) {</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;        <span class="keyword">const</span> Atom* currentAtom = <span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span>Atom*<span class="keyword">&gt;</span>(literal);</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;        <span class="keywordflow">if</span> (currentAtom != <span class="keyword">nullptr</span>) {</div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;            ++countAtoms;</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;            atom = currentAtom;</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;        }</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;    }</div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160; </div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;    <span class="keywordflow">if</span> (countAtoms &gt; 1) {</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;    }</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160; </div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;    <span class="keywordtype">bool</span> seenInnerAggregate = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;    <span class="comment">// If we have an aggregate within this aggregate =&gt; materialize</span></div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;    <a class="code" href="namespacesouffle_1_1ast.html#a0bf6b9bdf0a8866bd27dde18442ab43d">visitDepthFirst</a>(agg, [&amp;](<span class="keyword">const</span> Aggregator&amp; innerAgg) {</div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;        <span class="keywordflow">if</span> (agg != innerAgg) {</div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;            seenInnerAggregate = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;        }</div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;    });</div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160; </div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;    <span class="keywordflow">if</span> (seenInnerAggregate) {</div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;    }</div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160; </div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;    <span class="comment">// If the same variable occurs several times =&gt; materialize</span></div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;    <span class="keywordtype">bool</span> duplicates = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;    std::set&lt;std::string&gt; vars;</div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;    <span class="keywordflow">if</span> (atom != <span class="keyword">nullptr</span>) {</div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;        <a class="code" href="namespacesouffle_1_1ast.html#a0bf6b9bdf0a8866bd27dde18442ab43d">visitDepthFirst</a>(*atom, [&amp;](<span class="keyword">const</span> ast::Variable&amp; var) {</div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;            duplicates = duplicates || !vars.insert(var.getName()).second;</div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;        });</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;    }</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160; </div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;    <span class="comment">// If there are duplicates a materialization is required</span></div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;    <span class="comment">// for all others the materialization can be skipped</span></div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;    <span class="keywordflow">return</span> duplicates;</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;}</div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160; </div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;}  <span class="comment">// namespace souffle::ast::transform</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="abe3faf3909927c50112cc23824e2153e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe3faf3909927c50112cc23824e2153e">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::ast::transform::MaterializeAggregationQueriesTransformer::transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1ast_1_1_translation_unit.html">TranslationUnit</a> &amp;&#160;</td>
          <td class="paramname"><em>translationUnit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classsouffle_1_1ast_1_1transform_1_1_transformer.html#af861b2e661819fa1038829fede6e1c4f">souffle::ast::transform::Transformer</a>.</p>

<p class="definition">Definition at line <a class="el" href="_materialize_aggregation_queries_8h_source.html#l00064">64</a> of file <a class="el" href="_materialize_aggregation_queries_8h_source.html">MaterializeAggregationQueries.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>ast/transform/<a class="el" href="_materialize_aggregation_queries_8h_source.html">MaterializeAggregationQueries.h</a></li>
<li>ast/transform/<a class="el" href="_materialize_aggregation_queries_8cpp_source.html">MaterializeAggregationQueries.cpp</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="anamespacesouffle_1_1ast_1_1analysis_html_a03c482b5c5fefb75d263667dbe6b1995"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1analysis.html#a03c482b5c5fefb75d263667dbe6b1995">souffle::ast::analysis::isOfKind</a></div><div class="ttdeci">bool isOfKind(const Type &amp;type, TypeAttribute kind)</div><div class="ttdoc">Check if the type is of a kind corresponding to the TypeAttribute.</div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00189">TypeSystem.cpp:189</a></div></div>
<div class="ttc" id="aclasssouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer_html_ad6f0ae183cb14d8dab6bff286cb8ef95"><div class="ttname"><a href="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer.html#ad6f0ae183cb14d8dab6bff286cb8ef95">souffle::ast::transform::MaterializeAggregationQueriesTransformer::groundInjectedParameters</a></div><div class="ttdeci">static void groundInjectedParameters(const TranslationUnit &amp;translationUnit, Clause &amp;aggClause, const Clause &amp;originalClause, const Aggregator &amp;aggregate)</div><div class="ttdoc">Modify the aggClause by adding in grounding literals for every variable that appears in the clause un...</div><div class="ttdef"><b>Definition:</b> <a href="_materialize_aggregation_queries_8cpp_source.html#l00114">MaterializeAggregationQueries.cpp:114</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1analysis_html_ac1acc981f913d4ad9865fb655fe5e1f2"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1analysis.html#ac1acc981f913d4ad9865fb655fe5e1f2">souffle::ast::analysis::getLocalVariables</a></div><div class="ttdeci">std::set&lt; std::string &gt; getLocalVariables(const TranslationUnit &amp;tu, const Clause &amp;clause, const Aggregator &amp;aggregate)</div><div class="ttdoc">Computes the set of local variables in an aggregate expression.</div><div class="ttdef"><b>Definition:</b> <a href="_aggregate_8cpp_source.html#l00055">Aggregate.cpp:55</a></div></div>
<div class="ttc" id="aclasssouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer_html_aacd0bb77f62c0558f5c4213bce49bf12"><div class="ttname"><a href="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer.html#aacd0bb77f62c0558f5c4213bce49bf12">souffle::ast::transform::MaterializeAggregationQueriesTransformer::needsMaterializedRelation</a></div><div class="ttdeci">static bool needsMaterializedRelation(const Aggregator &amp;agg)</div><div class="ttdoc">A test determining whether the body of a given aggregation needs to be 'outlined' into an independent...</div><div class="ttdef"><b>Definition:</b> <a href="_materialize_aggregation_queries_8cpp_source.html#l00357">MaterializeAggregationQueries.cpp:357</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1analysis_html_a108a2d9570b44c655bf3165e8d8613d4"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1analysis.html#a108a2d9570b44c655bf3165e8d8613d4">souffle::ast::analysis::getGroundedTerms</a></div><div class="ttdeci">std::map&lt; const Argument *, bool &gt; getGroundedTerms(const TranslationUnit &amp;tu, const Clause &amp;clause)</div><div class="ttdoc">Analyse the given clause and computes for each contained argument whether it is a grounded value or n...</div><div class="ttdef"><b>Definition:</b> <a href="_ground_8cpp_source.html#l00278">Ground.cpp:278</a></div></div>
<div class="ttc" id="anamespacesouffle_html_af5361aa1e84030b37d7c8df1bf45e1c0a71fed0c3428bf1a2e19af257c4bac379"><div class="ttname"><a href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a71fed0c3428bf1a2e19af257c4bac379">souffle::TypeAttribute::Signed</a></div><div class="ttdeci">@ Signed</div></div>
<div class="ttc" id="anamespacesouffle_html_aecc08c83ad9634fc515b7aa094702949"><div class="ttname"><a href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">souffle::toString</a></div><div class="ttdeci">const std::string &amp; toString(const std::string &amp;str)</div><div class="ttdoc">A generic function converting strings into strings (trivial case).</div><div class="ttdef"><b>Definition:</b> <a href="_string_util_8h_source.html#l00234">StringUtil.h:234</a></div></div>
<div class="ttc" id="anamespacesouffle_html_adea839071e91666e99dedc870a42941c"><div class="ttname"><a href="namespacesouffle.html#adea839071e91666e99dedc870a42941c">souffle::clone</a></div><div class="ttdeci">auto clone(const std::vector&lt; A * &gt; &amp;xs)</div><div class="ttdef"><b>Definition:</b> <a href="_container_util_8h_source.html#l00172">ContainerUtil.h:172</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1test_html_a10453085bc4f71f32dcda443d4b3c446"><div class="ttname"><a href="namespacesouffle_1_1test.html#a10453085bc4f71f32dcda443d4b3c446">souffle::test::count</a></div><div class="ttdeci">int count(const C &amp;c)</div><div class="ttdef"><b>Definition:</b> <a href="table__test_8cpp_source.html#l00040">table_test.cpp:40</a></div></div>
<div class="ttc" id="aclasssouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer_html_ae2fb95a2da3c8f1dd34aff9d9299704d"><div class="ttname"><a href="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer.html#ae2fb95a2da3c8f1dd34aff9d9299704d">souffle::ast::transform::MaterializeAggregationQueriesTransformer::materializeAggregationQueries</a></div><div class="ttdeci">static bool materializeAggregationQueries(TranslationUnit &amp;translationUnit)</div><div class="ttdoc">Creates artificial relations for bodies of aggregation functions consisting of more than a single ato...</div><div class="ttdef"><b>Definition:</b> <a href="_materialize_aggregation_queries_8cpp_source.html#l00249">MaterializeAggregationQueries.cpp:249</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1analysis_html_aa937ef5b2452a42f1f884003aae88bf0"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1analysis.html#aa937ef5b2452a42f1f884003aae88bf0">souffle::ast::analysis::findUniqueRelationName</a></div><div class="ttdeci">std::string findUniqueRelationName(const Program &amp;program, std::string base)</div><div class="ttdoc">Find a new relation name.</div><div class="ttdef"><b>Definition:</b> <a href="_aggregate_8cpp_source.html#l00190">Aggregate.cpp:190</a></div></div>
<div class="ttc" id="aclasssouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer_html_abe3faf3909927c50112cc23824e2153e"><div class="ttname"><a href="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer.html#abe3faf3909927c50112cc23824e2153e">souffle::ast::transform::MaterializeAggregationQueriesTransformer::transform</a></div><div class="ttdeci">bool transform(TranslationUnit &amp;translationUnit) override</div><div class="ttdef"><b>Definition:</b> <a href="_materialize_aggregation_queries_8h_source.html#l00064">MaterializeAggregationQueries.h:64</a></div></div>
<div class="ttc" id="anamespacesouffle_html_aa26a7e6147aca5568158e38f08ffcf21a4905ac9d6a22bdfc1ae096094ce6248d"><div class="ttname"><a href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a4905ac9d6a22bdfc1ae096094ce6248d">souffle::AggregateOp::COUNT</a></div><div class="ttdeci">@ COUNT</div></div>
<div class="ttc" id="aclasssouffle_1_1ast_1_1analysis_1_1_type_analysis_html_a345c8fe0c38bfd5fe28922eb15fded8f"><div class="ttname"><a href="classsouffle_1_1ast_1_1analysis_1_1_type_analysis.html#a345c8fe0c38bfd5fe28922eb15fded8f">souffle::ast::analysis::TypeAnalysis::analyseTypes</a></div><div class="ttdeci">static std::map&lt; const Argument *, TypeSet &gt; analyseTypes(const TranslationUnit &amp;, const Clause &amp;, std::ostream *=nullptr)</div><div class="ttdoc">Analyse the given clause and computes for each contained argument a set of potential types.</div><div class="ttdef"><b>Definition:</b> <a href="_type_8cpp_source.html#l00818">Type.cpp:818</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_html_a0bf6b9bdf0a8866bd27dde18442ab43d"><div class="ttname"><a href="namespacesouffle_1_1ast.html#a0bf6b9bdf0a8866bd27dde18442ab43d">souffle::ast::visitDepthFirst</a></div><div class="ttdeci">void visitDepthFirst(const Node &amp;root, Visitor&lt; R, Ps... &gt; &amp;visitor, Args &amp;... args)</div><div class="ttdoc">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-...</div><div class="ttdef"><b>Definition:</b> <a href="ast_2utility_2_visitor_8h_source.html#l00273">Visitor.h:273</a></div></div>
<div class="ttc" id="aclasssouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer_html_a7f8a7cdbad4c5a5a5398055eec217693"><div class="ttname"><a href="classsouffle_1_1ast_1_1transform_1_1_materialize_aggregation_queries_transformer.html#a7f8a7cdbad4c5a5a5398055eec217693">souffle::ast::transform::MaterializeAggregationQueriesTransformer::distinguishHeadArguments</a></div><div class="ttdeci">static std::set&lt; std::string &gt; distinguishHeadArguments(const TranslationUnit &amp;tu, const Clause &amp;clause, const Aggregator &amp;aggregate)</div><div class="ttdoc">When we materialise an aggregate subclause, it's a good question which variables belong in the head o...</div><div class="ttdef"><b>Definition:</b> <a href="_materialize_aggregation_queries_8cpp_source.html#l00077">MaterializeAggregationQueries.cpp:77</a></div></div>
<div class="ttc" id="anamespacesouffle_1_1ast_1_1analysis_html_abbc7e3bf641dffe8a8dd0db3a8b44712"><div class="ttname"><a href="namespacesouffle_1_1ast_1_1analysis.html#abbc7e3bf641dffe8a8dd0db3a8b44712">souffle::ast::analysis::getInjectedVariables</a></div><div class="ttdeci">std::set&lt; std::string &gt; getInjectedVariables(const TranslationUnit &amp;tu, const Clause &amp;clause, const Aggregator &amp;aggregate)</div><div class="ttdoc">Given an aggregate and a clause, we find all the variables that have been injected into the aggregate...</div><div class="ttdef"><b>Definition:</b> <a href="_aggregate_8cpp_source.html#l00205">Aggregate.cpp:205</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
